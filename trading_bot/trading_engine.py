
from datetime import datetime, timedelta
from alpaca_market_data import *
from alpaca.data import TimeFrame
from broker import *
from market_data import *
from BuyCloseSellOpen import *
import time
from uuid import uuid4

class TradingEngine:
    """
    A generic trading engine for executing trading strategies.
    """

    def __init__(self, strategy: Strategy, broker: Broker, market_data: MarketData, capital: float):
        """
        Initialize the trading engine with a strategy, broker, and market data source.
        :param strategy: The trading strategy to be used.
        :param broker: The broker interface for executing trades.
        :param market_data: The market data interface for fetching data.
        :param capital: The capital allocated to this trading engine.
        """
        self.strategy = strategy
        self.strategy_id = strategy.strategy_id
        self.broker = broker
        self.trade_number = 0
        self.market_data = market_data
        self.capital = strategy.capital
        self.positions = {} 
        self.symbol = self.strategy.symbol 
        

    def run(self, start_date: datetime, end_date: datetime, sleep_interval: int = 60):
        """
        Run the trading engine for the specified time period.
        :param start_date: The start date for the trading engine. UTC!
        :param end_date: The end date for the trading engine. UTC!
        :param sleep_interval: Time (in seconds) to wait between iterations of the loop.
        """
        print("Starting Trading Engine...")
        while datetime.now() < end_date:
            print(f"Current time: {datetime.now()}")

            # Strategy generates trading signals
            now = datetime.now(utc)
            market_open = datetime.now(utc).replace(hour=14, minute=31, second=0, microsecond=0)
            if now > market_open + timedelta(minutes=30) and now < market_open + timedelta(hours=4):
                minute_bars = self.market_data.feed_bars(self.symbol, TimeFrame.Minute, start_time=now - timedelta(minutes=30), end_time=now)
            else:
                minute_bars = {}
            signal = self.strategy.generate_signal(last_close_price = self.market_data.get_last_close_price(self.symbol),
                                                   data = minute_bars,
                                                   current_price = self.market_data.get_current_price(self.symbol))
            print(signal)

            if signal:
                self.execute_trade(signal)

            # Simulate time delay to avoid high computational load
            print(f"Sleeping for {sleep_interval} seconds...")
            time.sleep(sleep_interval)  # Wait for the specified interval

        print("Trading Engine has stopped.")

    def execute_trade(self, signal: dict):
        """
        Execute a trade based on the signal.
        :param signal: The trading signal generated by the strategy.
        """
        action = signal.get("action")
        symbol = signal.get("symbol")
        quantity = float(signal.get("quantity"))
        price = signal.get("price")

        if action and symbol and quantity and price:
            print(f"Submitting {action} order for {quantity} shares of {symbol} at ${price}")
            # Pass the order to the broker
            self.broker.place_order(symbol=symbol, quantity = quantity, action = action, strategy_id = f"{self.strategy_id}_{self.trade_number}:{uuid4()}", trade_number = self.trade_number)
            self.trade_number = self.trade_number + 1
            # Update positions
            if action == "buy":
                self.positions[symbol] = self.positions.get(symbol, 0) + quantity
            elif action == "sell":
                self.positions[symbol] = self.positions.get(symbol, 0) - quantity

    

